const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const User = require('../models/users');
const jwt = require('jsonwebtoken');

// Helper to create token
const createToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.JWT_SECRET, { expiresIn: '7d' });
}; //token consists of HEADER.PAYLOAD.SIGNATURE
//jwt.sign(payload, secretOrPrivateKey, [options, callback]) sign means genarate signature
/*
1. Header-Tells the server what algorithm was used to sign the token and the token type
2. Payload-This is the data inside the token — what you want to store in the token.

  "id": "64babcd123456",
  "iat": 1699999999,
  "exp": 1700000000
}
id → your user’s unique ID (from MongoDB _id)
iat → issued at (timestamp)
exp → expiry timestamp

3. Signature-This is the proof the token was made by your server.
Generated by combining:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  SECRET_KEY
)
SECRET_KEY → your process.env.JWT_SECRET
Server uses this to verify the token wasn’t tampered with.
Browser cannot generate a valid signature without the secret.
*/

//SIGNUP ROUTE
//this defines a route on router instance
router.post('/signup', async (req, res) => {
  const { name, email, password } = req.body;

  // Validate fields
  if (!name || !email || !password) {
    return res.status(400).json({ message: 'All fields are required' });
    /*
    Access it like this in frontend axios:
    try {
      const response = await axios.post('/auth/signup', {
        name: '',
        email: '',
        password: ''
      });
    } catch (err) {
      // The server response is in err.response.data
      console.log(err.response.data.message); // "All fields are required"
    }
    */
  }

  try {
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ message: 'User already exists' });
    }

    // Hash password before saving
    const salt = await bcrypt.genSalt(10); // generates a salt with cost factor 10
    const hashedPassword = await bcrypt.hash(password, salt);

    // Create new user with hashed password
    //User with capital U refers to the User model imported at the top which defines schema
    const user = new User({ name: name, email, password: hashedPassword });
    //creates a new Mongoose document instance in memory.The object exists in your Node process but is not yet in the database.
    // should write email: email but in ES6 if key and value have same name we can write just once
    //creates a new document instance using the schema.
    await user.save();
    // .save() stores this user in MongoDB
    // Alternative: await User.create({ name, email, password: hashedPassword }); 1 line instead of 2,instantiates a document AND saves it in one step.
    // Pros: Shorter, cleaner syntax.Great if you don’t need to manipulate the document before saving


     const token = createToken(user._id); // calls the function I defined before createToken is user defined function
     
      res.cookie('token', token, {
      httpOnly: true, //JS on the frontend cannot read the cookie. Only sent in HTTP requests. Protects your token from XSS.
      //Browser JavaScript cannot read document.cookie to get this cookie.Defends against XSS(an attacker’s injected script can’t steal the cookie
      secure: false,// in production, set to true to send cookie only over HTTPS(not plain HTTP).Prevents network eavesdroppers from stealing the cookie
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000,// 7 days in milliseconds
    }); // sets cookie in browser
    //res.cookie(name, value, options)
    /*
    httpOnly: true
Browser JavaScript cannot read document.cookie to get this cookie.
→ Defends against XSS (an attacker’s injected script can’t steal the cookie).

secure: true
Cookie is sent only over HTTPS (not plain HTTP).
→ Prevents network eavesdroppers from stealing the cookie. In dev on localhost you usually set secure: false.

sameSite: 'lax' | 'strict' | 'none'
Controls whether the browser sends this cookie on cross-site requests.

1. 'strict' — cookie is only sent on same-site navigations (most restrictive). Good, but breaks some flows (e.g., third-party links).
2. 'lax' — default-ish safe option: cookie is sent on top-level navigations and GET requests (works for most apps).
3. 'none' — cookie is sent on cross-site requests only if secure: true is set. Use when embedding across domains (rare).
→ Mitigates CSRF(cross site request forgery) by limiting when cookies are automatically sent.

maxAge (milliseconds): How long the cookie lives before the browser deletes it. Example: 7 * 24 * 60 * 60 * 1000 → 7 days.

path (default '/') : URL path the cookie applies to. If path: '/api', browser sends cookie only on requests under /api/*.

domain: Restricts cookie to a domain. Use example.com to include subdomains (app.example.com), or omit to scope to the current host.
     */

    res.status(201).json({ message: 'Account Created' });
  } catch (err) {
    res.status(500).json({ message: 'Error creating user', error: err.message });
  }
});


//LOGIN route
router.post('/login', async(req,res)=>{
  const {email,password}=req.body;
  //validate fields
  if(!email || !password){
    return res.status(400).json({message:'All fields are required'});//frontend expects json, Without .json, if you did res.send({ message: "Hello" }), Express might convert it to something weird or send plain text — not guaranteed JSON.
  }

  try{
    const user=await User.findOne({email:email}); //right one is from req.body.email left one is the field in DB
    //returns the whole MongoDB document that matches that query, not just the email.
    if(!user){
      return res.status(401).json({message:"Email not registered. Sign up?"});
    }
    const isMatch=await bcrypt.compare(password,user.password);//right is from req.body, left is from DB
    if (!isMatch){
      return res.status(401).json({message:"Invalid password"});
    }
    const token=createToken(user._id);

    res.cookie('token', token,{
      httpOnly:true,
      secure: false,//in prod make it true
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    /*
    Sends a Set-Cookie header to the browser.
    Header example:
    Set-Cookie: token=abc123; HttpOnly; Max-Age=604800; Path=/
    Browser sees that → stores the cookie → attaches it automatically on future requests.
    */

    res.status(200).json({message:'Login successful'});
  }
  catch(err){
    res.status(500).json({message:'Server error during login', error: err.message});
  }
});



//LOGOUT route
router.post('/logout', (req, res) => {
  res.clearCookie('token');
  res.status(200).json({ message: 'Logged out successfully' });
});



//google-routes login and  sign up-----------------------------------

const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// GOOGLE LOGIN/SIGNUP
router.post('/google', async (req, res) => {
  const { token } = req.body; // Frontend sends the ID token from Google

  try {
    // Verify the token with Google
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const payload = ticket.getPayload();
    const { email, name, picture, sub } = payload; //'sub' = Google unique user ID

    // Check if user already exists
    let user = await User.findOne({ email });
    let isNewUser = false;

    if (!user) {
      // If not, create a new user
      user = await User.create({
        name,
        email,
        password: null, //no password since Google handles auth
        googleId: sub,
        profilePic: picture,
      });
      isNewUser = true;
    }

    // Create your own JWT token for session management
    const jwtToken = createToken(user._id);

    res.cookie('token', jwtToken, {
      httpOnly: true,
      secure: false, // change to true in prod (HTTPS)
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });

    res.status(200).json({
      message: 'Google login successful',
      user: {
        name: user.name,
        email: user.email,
        profilePic: user.profilePic,
      },
      isNewUser
    });
  } catch (err) {
    console.error(err);
    res.status(401).json({ message: 'Invalid Google token', error: err.message });
  }
});


module.exports = router;
/*
module.exports is the Node.js syntax for exporting something
from a file so that other files can import it.

Example:
// math.js
module.exports = function add(a, b) {
  return a + b;
};

// main.js
const add = require('./math');
console.log(add(2, 3)); // 5

Here, module.exports was assigned a function, and that’s what require() returns.

const authRoutes = require('./authRoutes'); in index.js is used to import this file
*/
